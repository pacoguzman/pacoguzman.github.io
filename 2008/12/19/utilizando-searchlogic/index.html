<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width initial-scale=1" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge">

      <title>Utilizando Searchlogic</title>
      <meta name="description" content="Personal blog about Ruby and Rails development and live experiences">
      <meta name="viewport" content="width=device-width, initial-scale=1">

      <link rel="canonical" href="https://pacoguzman.github.io/2008/12/19/utilizando-searchlogic/">
      <link rel="stylesheet" href="/assets/application.css?cb=38dd5d53ee15645b619f25a3939dc4af">

      <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-58160626-1', 'auto');
          ga('send', 'pageview');

      </script>
  </head>

  <body>
    <header class="navigation">
  <div class="menu-wrapper">
    <a href="javascript:void(0)" class="logo">
      <img src="https://raw.github.com/Magnus-G/Random/master/placeholder_logo_1.png" alt="">
    </a>
    <p class="navigation-menu-button" id="js-mobile-menu">MENU</p>
    <div class="nav">
      <ul id="navigation-menu">
        
          
            <li class="nav-link"><a href="/">Riding to NoWhere</a></li>
          
        
          
            <li class="nav-link"><a href="/posts">Posts</a></li>
          
        
      </ul>
    </div>
  </div>
</header>

<script>
  $(function() {
    var menu = $('#navigation-menu');
    var menuToggle = $('#js-mobile-menu');
    var signUp = $('.sign-up');

    $(menuToggle).on('click', function(e) {
      e.preventDefault();
      menu.slideToggle(function(){
        if(menu.is(':hidden')) {
          menu.removeAttr('style');
        }
      });
    });

    // underline under the active nav item
    $(".nav .nav-link").click(function() {
      $(".nav .nav-link").each(function() {
        $(this).removeClass("active-nav-item");
      });
      $(this).addClass("active-nav-item");
      $(".nav .more").removeClass("active-nav-item");
    });
  });
</script>

    <div class="page-content">
        <div class="wrap">
            <div class="post">

  <header class="post-header">
    <h1>Utilizando Searchlogic</h1>
    <p class="meta">Dec 19, 2008</p>
  </header>

  <article class="post-content">
  <p>De entre los repositorios de GitHub que sigo se encuentra SearchLogic. Una gema que facilita la búsqueda, paginación, y ordenación and more! en objetos ActiveRecord.</p>

<p>En una aplicación que estoy trabajando me ha surgido la necesidad de crear un buscador (formulario) en el que se pueden incluir ciertos criterio de búsqueda, la lista de los mismos esta por ampliar.</p>

<p>Dentro de los criterios actuales se encuentra la posiblidad de introducir keywords y dentro de un select determinar un rango numérico de distancia a utilizar en la búsqueda.</p>

<p>Como este formulario crecerá con el tiempo he querido buscar una solución que me permite introducir nuevos criterios de forma poco invasiva y sin reinventar la rueda.</p>

<p>Entremos en detalle:</p>

<p>Con SearchLogic es posible establecer condiciones de búsqueda de keywords del siguiente modo:</p>

<blockquote>
  <p>:keywords                     :kwords, :kw                        Splits into each word and omits meaningless words, a true keyword search</p>
</blockquote>

<pre><code class="language-ruby">search.conditions( :keywords =&gt; params[:search][:keywords])
</code></pre>

<p>Sin embargo en mi caso quiero buscar keywords en dos campos por lo que tengo que crear un grupo con condicion OR ya que no es necesario que el keyword este presente en ambos campos. Hago lo siguiente&lt;</p>

<pre><code class="language-ruby">search.conditions.group do |group|
 group.nombre_kw = params[:search][:keyword]
 group.or_descripcion_kw = params[:search][:keyword]
end
# SELECT rutas.* FROM rutas WHERE ( rutas.nombre LIKE "%keyword1%" OR rutas.descripcion LIKE "%keyword1%" AND rutas.nombre LIKE "%keywordi%" OR rutas.descripcion LIKE "%keywordi%")
</code></pre>

<p>o bien</p>

<pre><code class="language-ruby">search(:conditions =&gt; {:group =&gt; {:name_kw =&gt; keyword, :or_descripcion_kw =&gt; keyword }} )
</code></pre>

<p>Por lo tanto me creo el siguiente método</p>

<pre><code class="language-ruby">def condicion_distancia(code)
  code ||= "0"
  case code
    when "0"; {}
    when "1"; {:distancia_lt =&gt; 10}
    when "2"; {:distancia_gte =&gt; 10, :distancia lt =&gt; 25}
    when "3"; {:distancia_gte =&gt; 25, :distancia lt =&gt; 50}
    when "4"; {:distancia_gte =&gt; 50}
  end
end
</code></pre>

<p>Para los rangos numéricos de distancia los establezco por correspondencia con un código del siguiente modo:</p>

<pre><code class="language-ruby">def condicion_distancia(code)
  code ||= "0"
  case code
    when "0"; {}
    when "1"; {:distancia_lt =&gt; 10}
    when "2"; {:distancia_gte =&gt; 10, :distancia lt =&gt; 25}
    when "3"; {:distancia_gte =&gt; 25, :distancia lt =&gt; 50}
    when "4"; {:distancia_gte =&gt; 50}
  end
end
</code></pre>

<pre><code class="language-ruby">search(:conditions =&gt; condificion_distancia(params[:search][:distance]))
``

Para agrupar todas las condiciones de cada uno de los criterios de búsqueda que vaya a establecer me he creado el siguiente método

```ruby
def compute_searchlogic_conditions(search)
  conditions = {}
  conditions.merge!(condicion_distancia(search[:distancia])) unless search[:distancia].blank?
  conditions.merge!(condicion_keywords(search[:keywords])) unless search[:keywords].blank?
  # Sucesivas condiciones
end
</code></pre>

<p>Ahora solo queda utilizarlo en el controlador</p>

<pre><code class="language-ruby">def index
  search = Ruta.new_search(:conditions =&gt; compute_searchlogic_conditions(params[:search]))
  rutas = search.all.paginate(:page =&gt; @page, :per_page =&gt; 10, :order =&gt; @order)
end
</code></pre>

<p>Con SearchLogic es posible incluir la paginación y la ordenación a la hora crear el objeto search pero incluye su propio sistema de paginación y no es compatible directamente con mislav-will_paginate. Si se quiere usar la paginación de SearchLogic lo hariamos de la siguiente forma:</p>

  </article>

</div>
        </div>
    </div>

    <script type="text/javascript" src="/assets/application.js?cb=23dc9061ba93ec68527e675c87e0c367"></script>
  </body>

</html>
